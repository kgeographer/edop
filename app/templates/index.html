{% extends "base.html" %}

{% block content %}
<div class="container-fluid">
  <div class="row g-3">

    <!-- LEFT: tabs + forms + outputs -->
    <div class="col-12 col-lg-4">
      <ul class="nav nav-tabs" id="edopTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="tab-main" data-bs-toggle="tab" data-bs-target="#panel-main" type="button" role="tab" aria-controls="panel-main" aria-selected="true">Main</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="tab-compare" data-bs-toggle="tab" data-bs-target="#panel-compare" type="button" role="tab" aria-controls="panel-compare" aria-selected="false">Compare</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="tab-whc" data-bs-toggle="tab" data-bs-target="#panel-whc" type="button" role="tab" aria-controls="panel-whc" aria-selected="false">WH Cities</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="tab-wh" data-bs-toggle="tab" data-bs-target="#panel-wh" type="button" role="tab" aria-controls="panel-wh" aria-selected="false">WH Sites</button>
        </li>
      </ul>

      <div class="tab-content pt-3" id="edopTabContent">

        <!-- MAIN TAB -->
        <div class="tab-pane fade" id="panel-main" role="tabpanel" aria-labelledby="tab-main">
          <h4 class="mb-3">Resolve place</h4>

          <form id="main-form" class="mb-3">
            <div class="mb-2">
              <label class="form-label" for="main-lon">Longitude</label>
              <input class="form-control" id="main-lon" name="lon" type="number" step="any" placeholder="e.g. -2.99944" />
            </div>
            <div class="mb-2">
              <label class="form-label" for="main-lat">Latitude</label>
              <input class="form-control" id="main-lat" name="lat" type="number" step="any" placeholder="e.g. 16.77333" />
            </div>

            <div class="my-3 text-muted">— or —</div>

            <div class="mb-2">
              <label class="form-label" for="main-name">Place name (WHG suggest; first hit only)</label>
              <input class="form-control" id="main-name" name="name" type="text" placeholder="e.g. Timbuktu" />
              <div class="form-text">Name resolution uses WHG via the EDOP backend (top-ranked hit only); the WHG token is never sent to the browser.</div>
            </div>

            <div class="d-flex gap-2 mt-3">
              <button class="btn btn-primary" id="main-resolve-btn" type="submit">Resolve</button>
              <button class="btn btn-outline-secondary" id="test-btn" type="button">Use Timbuktu lon/lat</button>
            </div>
          </form>
        </div>

        <!-- COMPARE TAB (placeholder) -->
        <div class="tab-pane fade" id="panel-compare" role="tabpanel" aria-labelledby="tab-compare">
          <p class="text-muted">Compare UI coming next (two places → two profiles).</p>
        </div>

        <!-- WORLD HERITAGE TAB (pilot 20 sites) -->
        <div class="tab-pane fade" id="panel-wh" role="tabpanel" aria-labelledby="tab-wh">
          <h4 class="mb-3">20 World Heritage sites</h4>

          <div class="mb-2">
            <label class="form-label" for="wh-select">Choose a site</label>
            <select class="form-select" id="wh-select" disabled>
              <option value="">Loading…</option>
            </select>
<!--            <div class="form-text">Seed list will come from the EDOP backend; selecting a site will drop a marker and compute an environmental profile.</div>-->
          </div>

          <div class="mt-3 d-flex gap-2">
            <button class="btn btn-outline-secondary" id="wh-show-desc" type="button" disabled>Show description</button>
            <button class="btn btn-outline-primary" id="wh-similar-env" type="button" disabled>Similar (env)</button>
            <button class="btn btn-outline-info" id="wh-similar-text" type="button" disabled>Similar (semantic)</button>
          </div>

          <div class="mt-3">
            <div class="alert alert-light" id="wh-desc" style="display:none;"></div>
          </div>
        </div>

        <!-- WH CITIES TAB (258 cities) -->
        <div class="tab-pane fade show active" id="panel-whc" role="tabpanel" aria-labelledby="tab-whc">
          <h4 class="mb-3">258 World Heritage Cities</h4>

          <div class="mb-2">
            <label class="form-label" for="whc-select">Choose a city</label>
            <select class="form-select" id="whc-select" disabled>
              <option value="">Loading…</option>
            </select>
            <div class="form-text">Grouped by UNESCO region. Select to view environmental profile and similarity.</div>
          </div>

          <div class="mt-3 d-flex gap-2 flex-wrap">
            <!-- Environmental similarity dropdown -->
            <div class="dropdown">
              <button class="btn btn-outline-primary dropdown-toggle" type="button" id="whc-similar-env-btn" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                Similar (env)
              </button>
              <ul class="dropdown-menu" aria-labelledby="whc-similar-env-btn">
                <li><a class="dropdown-item" href="#" data-band="composite">Composite</a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item disabled text-muted" href="#" data-band="A">A – Physiographic bedrock</a></li>
                <li><a class="dropdown-item disabled text-muted" href="#" data-band="B">B – Hydro-climatic baselines</a></li>
                <li><a class="dropdown-item disabled text-muted" href="#" data-band="C">C – Bioclimatic proxies</a></li>
                <li><a class="dropdown-item disabled text-muted" href="#" data-band="D">D – Anthropocene markers</a></li>
              </ul>
            </div>

            <!-- Semantic similarity dropdown -->
            <div class="dropdown">
              <button class="btn btn-outline-info dropdown-toggle" type="button" id="whc-similar-text-btn" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                Similar (semantic)
              </button>
              <ul class="dropdown-menu" aria-labelledby="whc-similar-text-btn">
                <li><a class="dropdown-item" href="#" data-band="composite">Composite</a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item" href="#" data-band="environment">Environment</a></li>
                <li><a class="dropdown-item" href="#" data-band="history">History</a></li>
                <li><a class="dropdown-item" href="#" data-band="culture">Culture</a></li>
                <li><a class="dropdown-item" href="#" data-band="modern">Modern</a></li>
              </ul>
            </div>
          </div>

          <div class="mt-3">
            <div class="alert alert-light" id="whc-status" style="display:none;"></div>
          </div>
        </div>

      </div>

      <!-- Outputs (shared across tabs) -->
      <div class="mt-3">
        <h5 class="mb-2">Environmental profile</h5>

        <!-- Cluster label (shown for WH sites) -->
        <div id="cluster-label" class="mb-2" style="display:none;">
          <span class="badge bg-secondary fs-6" id="cluster-label-text"></span>
        </div>

        <!-- Summary + grouped accordions (preferred) -->
        <div id="profile-summary" class="small"></div>
        <div id="profile-accordions" class="mt-2"></div>

        <!-- Fallback (raw JSON) -->
        <pre id="output" class="bg-light p-2" style="min-height: 12rem; display:none;"></pre>
      </div>

      <div id="resolved-place-section" class="mb-3 mt-3" style="display:none;">
        <h5 class="mb-2">Resolved place</h5>
        <pre id="main-resolved" class="bg-light p-2" style="min-height: 7rem;"></pre>
      </div>
    </div>

    <!-- RIGHT: map (always visible) -->
    <div class="col-12 col-lg-7">
<!--      <h4 class="mb-3">Map</h4>-->
      <div id="map" style="height: 420px; border: 1px solid #ddd;"></div>
      <style>
        /* Hillshade blend: keeps relief legible when reference tiles (streets/labels) are toggled on.
           Note: mix-blend-mode behavior can vary slightly across browsers. */
        .edop-hillshade {
          mix-blend-mode: multiply;
        }
      </style>
<!--      <div class="form-text mt-2">Map plumbing is wired for a marker now; polygon overlay can be added once <code>/api/signature</code> returns GeoJSON geometry.</div>-->

      <!-- Similar sites results (shown below map) -->
      <div id="similar-results" class="mt-3" style="display:none;">
        <h5 class="mb-0" id="similar-heading">Most Similar Sites</h5>
        <p class="fst-italic small" id="similar-description"></p>
        <div id="similar-list"></div>
      </div>
    </div>

  </div>
</div>

<!-- City Summaries Modal -->
<div class="modal fade" id="summariesModal" tabindex="-1" aria-labelledby="summariesModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="summariesModalLabel">City Summaries</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="summariesModalBody">
        <div class="text-center text-muted">Loading...</div>
      </div>
    </div>
  </div>
</div>

<script>
  // ResolvedPlace shape (client-side):
  // {
  //   label: string,
  //   source: 'lonlat' | 'whg_suggest',
  //   location?: { type: 'Point', coordinates: [lon, lat] },
  //   meta?: object
  // }

  let map = null;
  let marker = null;
  let basinLayer = null; // GeoJSON polygon overlay from signature (sub-basin)
  let similarMarkers = []; // Markers for similar sites
  // World Heritage seed list state (pilot 20 sites)
  let whSites = [];
  let whSelected = null;

  // WHC Cities state (258 cities)
  let whcCities = [];
  let whcSelected = null;
  function setMarkerWithPopup(lon, lat, popupHtml) {
    setMarkerFromLonLat(lon, lat);
    if (!marker) return;
    marker.unbindPopup();
    if (popupHtml) {
      marker.bindPopup(popupHtml);
    }
  }

  function whSetStatus(msg) {
    // Lightweight status: show in description alert area if present, else console.
    const el = document.getElementById('wh-desc');
    if (!el) {
      console.log(msg);
      return;
    }
    if (!msg) {
      el.style.display = 'none';
      el.textContent = '';
      return;
    }
    el.style.display = '';
    el.textContent = msg;
  }

  async function whLoadSites() {
    const sel = document.getElementById('wh-select');
    const btnDesc = document.getElementById('wh-show-desc');
    const descBox = document.getElementById('wh-desc');

    if (!sel) return;

    sel.disabled = true;
    if (btnDesc) btnDesc.disabled = true;
    if (descBox) {
      descBox.style.display = 'none';
      descBox.textContent = '';
    }

    sel.innerHTML = '<option value="">Loading…</option>';

    try {
      const resp = await fetch('/api/wh-sites');
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`WH sites request failed (${resp.status}): ${txt}`);
      }
      const data = await resp.json();
      whSites = (data && data.sites) ? data.sites : [];

      // Populate dropdown
      sel.innerHTML = '<option value="">Select a site…</option>';
      whSites.forEach((s) => {
        const opt = document.createElement('option');
        opt.value = String(s.id_no);
        opt.textContent = s.name_en;
        sel.appendChild(opt);
      });

      sel.disabled = false;
    } catch (e) {
      sel.innerHTML = '<option value="">(Seed list unavailable)</option>';
      sel.disabled = true;
      whSetStatus(String(e));
    }
  }

  function showClusterLabel(label) {
    const container = document.getElementById('cluster-label');
    const text = document.getElementById('cluster-label-text');
    if (!container || !text) return;

    if (label) {
      text.textContent = label;
      container.style.display = '';
    } else {
      text.textContent = '';
      container.style.display = 'none';
    }
  }

  function clearSimilarMarkers() {
    similarMarkers.forEach(m => {
      if (map) map.removeLayer(m);
    });
    similarMarkers = [];
  }

  function clearSimilarResults() {
    const container = document.getElementById('similar-results');
    const list = document.getElementById('similar-list');
    if (container) container.style.display = 'none';
    if (list) list.innerHTML = '';
    clearSimilarMarkers();
  }

  async function fetchSimilarSites(idNo, limit = 5) {
    const url = `/api/similar?id_no=${encodeURIComponent(idNo)}&limit=${limit}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`Similar sites request failed (${resp.status}): ${txt}`);
    }
    return await resp.json();
  }

  async function fetchSimilarTextSites(idNo, limit = 5) {
    const url = `/api/similar-text?id_no=${encodeURIComponent(idNo)}&limit=${limit}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`Similar text sites request failed (${resp.status}): ${txt}`);
    }
    return await resp.json();
  }

  // Color palette for similar sites (distinct, colorblind-friendly)
  const SIMILAR_COLORS = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00'];

  function renderSimilarSites(data, sourceSite, similarityType = 'env') {
    const container = document.getElementById('similar-results');
    const list = document.getElementById('similar-list');
    const heading = document.getElementById('similar-heading');
    const description = document.getElementById('similar-description');
    if (!container || !list) return;

    // Set heading and description based on similarity type
    if (heading && description) {
      if (similarityType === 'text') {
        heading.textContent = 'Similar Sites (Semantic)';
        description.textContent = 'computed from Wikipedia text embeddings using cosine similarity';
      } else {
        heading.textContent = 'Similar Sites (Environmental)';
        description.textContent = 'computed from the multivariate environmental profile using dimensionality reduction and clustering';
      }
    }

    const similar = data.similar || [];
    if (!similar.length) {
      list.innerHTML = '<div class="text-muted">No similar sites found.</div>';
      container.style.display = '';
      return;
    }

    // Build list HTML with color swatches
    const isText = similarityType === 'text';
    const rows = similar.map((site, idx) => {
      const color = SIMILAR_COLORS[idx % SIMILAR_COLORS.length];
      const sameCluster = site.cluster_label === sourceSite.cluster_label;
      const clusterNote = sameCluster
        ? `<span class="text-success small">same cluster</span>`
        : `<span class="text-muted small">${site.cluster_label || ''}</span>`;
      // Text similarity returns 'similarity', env returns 'distance'
      const metricLabel = isText ? 'sim' : 'dist';
      const metricValue = isText ? site.similarity : site.distance;
      return `
        <div class="d-flex justify-content-between align-items-center py-2 border-bottom">
          <div>
            <strong>${idx + 1}.</strong> ${escapeHtml(site.name_en)}
            <div class="small">${clusterNote}</div>
          </div>
          <div class="d-flex align-items-center gap-2">
            <span class="text-muted small">${metricLabel}: ${metricValue}</span>
            <span style="display:inline-block; width:16px; height:16px; background:${color}; border-radius:3px;"></span>
          </div>
        </div>
      `;
    }).join('');

    list.innerHTML = rows;
    container.style.display = '';

    // Add markers for similar sites
    clearSimilarMarkers();
    ensureMap();

    const bounds = [];

    // Include source site in bounds
    if (sourceSite.location && sourceSite.location.coordinates) {
      bounds.push([sourceSite.location.coordinates[1], sourceSite.location.coordinates[0]]);
    }

    similar.forEach((site, idx) => {
      const lat = site.lat;
      const lon = site.lon;
      const color = SIMILAR_COLORS[idx % SIMILAR_COLORS.length];
      bounds.push([lat, lon]);

      // Colored marker matching list swatch
      const simMarker = L.circleMarker([lat, lon], {
        radius: 10,
        fillColor: color,
        color: '#fff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.9
      }).addTo(map);

      simMarker.bindPopup(`
        <div style="max-width: 200px;">
          <strong>${idx + 1}. ${site.name_en}</strong><br/>
          <span class="text-muted">Distance: ${site.distance}</span><br/>
          <span class="small">${site.cluster_label || ''}</span>
        </div>
      `);

      similarMarkers.push(simMarker);
    });

    // Zoom to fit all markers
    if (bounds.length > 1 && map) {
      map.fitBounds(bounds, { padding: [50, 50] });
    }
  }

  async function whShowSimilarEnv() {
    if (!whSelected) return;

    const btnSimilar = document.getElementById('wh-similar-env');
    if (btnSimilar) btnSimilar.disabled = true;

    clearSimilarResults();

    try {
      whSetStatus('Finding environmentally similar sites…');
      const data = await fetchSimilarSites(whSelected.id_no, 5);
      renderSimilarSites(data, whSelected, 'env');
      whSetStatus('');
    } catch (e) {
      whSetStatus(String(e));
    } finally {
      if (btnSimilar) btnSimilar.disabled = false;
    }
  }

  async function whShowSimilarText() {
    if (!whSelected) return;

    const btnSimilar = document.getElementById('wh-similar-text');
    if (btnSimilar) btnSimilar.disabled = true;

    clearSimilarResults();

    try {
      whSetStatus('Finding semantically similar sites…');
      const data = await fetchSimilarTextSites(whSelected.id_no, 5);
      renderSimilarSites(data, whSelected, 'text');
      whSetStatus('');
    } catch (e) {
      whSetStatus(String(e));
    } finally {
      if (btnSimilar) btnSimilar.disabled = false;
    }
  }

  async function whSelectById(idNo) {
    const btnDesc = document.getElementById('wh-show-desc');
    const btnSimilarEnv = document.getElementById('wh-similar-env');
    const btnSimilarText = document.getElementById('wh-similar-text');
    const descBox = document.getElementById('wh-desc');

    whSelected = whSites.find((s) => String(s.id_no) === String(idNo)) || null;

    // Clear previous results
    if (descBox) {
      descBox.style.display = 'none';
      descBox.textContent = '';
    }
    if (btnDesc) btnDesc.textContent = 'Show description';
    clearSimilarResults();

    if (!whSelected) {
      if (btnDesc) btnDesc.disabled = true;
      if (btnSimilarEnv) btnSimilarEnv.disabled = true;
      if (btnSimilarText) btnSimilarText.disabled = true;
      showClusterLabel(null);
      return;
    }

    // Show cluster label if available
    showClusterLabel(whSelected.cluster_label);

    // Enable Similar buttons
    if (btnSimilarEnv) btnSimilarEnv.disabled = false;
    if (btnSimilarText) btnSimilarText.disabled = false;

    // This path is not WHG resolution; clear Resolved place
    renderResolvedPlace(null);

    const loc = whSelected.location;
    if (!loc || loc.type !== 'Point' || !loc.coordinates || loc.coordinates.length < 2) {
      whSetStatus('Selected site has no usable Point geometry.');
      if (btnDesc) btnDesc.disabled = true;
      return;
    }

    const lon = Number(loc.coordinates[0]);
    const lat = Number(loc.coordinates[1]);

    const popupHtml = `
      <div style="max-width: 260px;">
        <strong>${whSelected.name_en}</strong><br/>
        <span class="text-muted">${whSelected.states_name_en || ''}</span>
      </div>
    `;
    setMarkerWithPopup(lon, lat, popupHtml);

    // Enable description button if text exists
    if (btnDesc) btnDesc.disabled = !(whSelected.short_description_en && whSelected.short_description_en.length);

    try {
      whSetStatus('Computing environmental profile…');
      const sig = await fetchSignature(lon, lat);
      renderSignature(sig);
      setBasinFromSignature(sig);
      whSetStatus('');
      if (marker && marker.getPopup()) marker.openPopup();
    } catch (e) {
      whSetStatus(String(e));
      renderSignature({ error: String(e) });
    }
  }

  // -----------------------
  // WHC Cities (258) functions
  // -----------------------

  function whcSetStatus(msg) {
    const el = document.getElementById('whc-status');
    if (!el) {
      console.log(msg);
      return;
    }
    if (!msg) {
      el.style.display = 'none';
      el.textContent = '';
      return;
    }
    el.style.display = '';
    el.textContent = msg;
  }

  async function whcLoadCities() {
    const sel = document.getElementById('whc-select');
    if (!sel) return;

    sel.disabled = true;
    sel.innerHTML = '<option value="">Loading…</option>';

    try {
      const resp = await fetch('/api/whc-cities');
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`WHC cities request failed (${resp.status}): ${txt}`);
      }
      const data = await resp.json();
      whcCities = (data && data.cities) ? data.cities : [];

      // Group by region
      const byRegion = {};
      whcCities.forEach((c) => {
        const region = c.region || 'Other';
        if (!byRegion[region]) byRegion[region] = [];
        byRegion[region].push(c);
      });

      // Build grouped dropdown
      sel.innerHTML = '<option value="">Select a city…</option>';
      Object.keys(byRegion).sort().forEach((region) => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = region;
        byRegion[region].forEach((c) => {
          const opt = document.createElement('option');
          opt.value = String(c.id);
          opt.textContent = `${c.city}, ${c.country}`;
          optgroup.appendChild(opt);
        });
        sel.appendChild(optgroup);
      });

      sel.disabled = false;
    } catch (e) {
      sel.innerHTML = '<option value="">(Cities unavailable)</option>';
      sel.disabled = true;
      whcSetStatus(String(e));
    }
  }

  async function whcSelectById(cityId) {
    const btnSimilarEnv = document.getElementById('whc-similar-env-btn');
    const btnSimilarText = document.getElementById('whc-similar-text-btn');

    whcSelected = whcCities.find((c) => String(c.id) === String(cityId)) || null;

    // Clear previous state
    clearSimilarResults();
    whcSetStatus('');

    if (!whcSelected) {
      if (btnSimilarEnv) btnSimilarEnv.disabled = true;
      if (btnSimilarText) btnSimilarText.disabled = true;
      showClusterLabel(null);
      return;
    }

    // Show environmental cluster label
    showClusterLabel(whcSelected.env_cluster_label || null);

    // Enable Similar dropdown buttons
    if (btnSimilarEnv) btnSimilarEnv.disabled = false;
    if (btnSimilarText) btnSimilarText.disabled = false;

    // Clear Resolved place (this is not WHG resolution)
    renderResolvedPlace(null);

    const loc = whcSelected.location;
    if (!loc || loc.type !== 'Point' || !loc.coordinates || loc.coordinates.length < 2) {
      whcSetStatus('Selected city has no usable Point geometry.');
      return;
    }

    const lon = Number(loc.coordinates[0]);
    const lat = Number(loc.coordinates[1]);

    const popupHtml = `
      <div style="max-width: 260px;">
        <strong>${whcSelected.city}</strong><br/>
        <span class="text-muted">${whcSelected.country} (${whcSelected.region})</span>
      </div>
    `;
    setMarkerWithPopup(lon, lat, popupHtml);

    try {
      whcSetStatus('Computing environmental profile…');
      const sig = await fetchSignature(lon, lat);
      renderSignature(sig);
      setBasinFromSignature(sig);
      whcSetStatus('');
      if (marker && marker.getPopup()) marker.openPopup();
    } catch (e) {
      whcSetStatus(String(e));
      renderSignature({ error: String(e) });
    }
  }

  async function fetchWhcSimilarEnv(cityId, limit = 5) {
    const url = `/api/whc-similar?city_id=${encodeURIComponent(cityId)}&limit=${limit}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`WHC similar request failed (${resp.status}): ${txt}`);
    }
    return await resp.json();
  }

  async function fetchWhcSimilarText(cityId, band = 'composite', limit = 5) {
    const url = `/api/whc-similar-text?city_id=${encodeURIComponent(cityId)}&band=${encodeURIComponent(band)}&limit=${limit}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`WHC similar-text request failed (${resp.status}): ${txt}`);
    }
    return await resp.json();
  }

  function renderWhcSimilarSites(data, sourceSite, similarityType = 'env', band = 'composite') {
    const container = document.getElementById('similar-results');
    const list = document.getElementById('similar-list');
    const heading = document.getElementById('similar-heading');
    const description = document.getElementById('similar-description');
    if (!container || !list) return;

    // Set heading and description based on similarity type and band
    if (heading && description) {
      if (similarityType === 'text') {
        const bandLabel = SEMANTIC_BAND_LABELS[band] || band;
        heading.textContent = `Similar Cities (Semantic: ${bandLabel})`;
        description.textContent = 'computed from Wikipedia text embeddings using cosine similarity';
      } else {
        heading.textContent = 'Similar Cities (Environmental: Composite)';
        description.textContent = 'computed from basin environmental signatures using PCA distance';
      }
    }

    const similar = data.similar || [];
    if (!similar.length) {
      list.innerHTML = '<div class="text-muted">No similar cities found.</div>';
      container.style.display = '';
      return;
    }

    // Build list HTML with color swatches
    const isText = similarityType === 'text';
    const rows = similar.map((site, idx) => {
      const color = SIMILAR_COLORS[idx % SIMILAR_COLORS.length];
      const sameCluster = site.env_cluster === sourceSite.env_cluster;
      let clusterNote = '';
      if (!isText) {
        // For env similarity, show cluster label
        clusterNote = sameCluster
          ? `<span class="text-success small">same cluster</span>`
          : `<span class="text-muted small">${site.env_cluster_label || ''}</span>`;
      }
      const metricLabel = isText ? 'sim' : 'dist';
      const metricValue = isText ? site.similarity : site.distance;
      // For semantic similarity, make city name clickable to show summaries
      const cityDisplay = isText
        ? `<a href="#" class="text-decoration-none" onclick="showCitySummaries(${site.id}, '${escapeHtml(site.city).replace(/'/g, "\\'")}', '${escapeHtml(site.country).replace(/'/g, "\\'")}'); return false;">${escapeHtml(site.city)}, ${escapeHtml(site.country)}</a>`
        : `${escapeHtml(site.city)}, ${escapeHtml(site.country)}`;
      return `
        <div class="d-flex justify-content-between align-items-center py-2 border-bottom">
          <div>
            <strong>${idx + 1}.</strong> ${cityDisplay}
            <div class="small">${clusterNote}</div>
          </div>
          <div class="d-flex align-items-center gap-2">
            <span class="text-muted small">${metricLabel}: ${metricValue}</span>
            <span style="display:inline-block; width:16px; height:16px; background:${color}; border-radius:3px;"></span>
          </div>
        </div>
      `;
    }).join('');

    list.innerHTML = rows;
    container.style.display = '';

    // Add markers for similar sites
    clearSimilarMarkers();
    ensureMap();

    const bounds = [];

    // Include source site in bounds
    if (sourceSite.location && sourceSite.location.coordinates) {
      bounds.push([sourceSite.location.coordinates[1], sourceSite.location.coordinates[0]]);
    }

    similar.forEach((site, idx) => {
      const lat = site.lat;
      const lon = site.lon;
      if (!lat || !lon) return;
      const color = SIMILAR_COLORS[idx % SIMILAR_COLORS.length];
      bounds.push([lat, lon]);

      const simMarker = L.circleMarker([lat, lon], {
        radius: 10,
        fillColor: color,
        color: '#fff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.9
      }).addTo(map);

      const metricLabel = isText ? 'Similarity' : 'Distance';
      const metricValue = isText ? site.similarity : site.distance;
      simMarker.bindPopup(`
        <div style="max-width: 200px;">
          <strong>${idx + 1}. ${site.city}</strong><br/>
          <span class="text-muted">${site.country}</span><br/>
          <span class="small">${metricLabel}: ${metricValue}</span>
        </div>
      `);

      similarMarkers.push(simMarker);
    });

    // Zoom to fit all markers
    if (bounds.length > 1 && map) {
      map.fitBounds(bounds, { padding: [50, 50] });
    }
  }

  async function whcShowSimilarEnv(band = 'composite') {
    if (!whcSelected) return;

    const btn = document.getElementById('whc-similar-env-btn');
    if (btn) btn.disabled = true;

    clearSimilarResults();

    try {
      whcSetStatus('Finding environmentally similar cities…');
      const data = await fetchWhcSimilarEnv(whcSelected.id, 5);
      renderWhcSimilarSites(data, whcSelected, 'env');
      whcSetStatus('');
    } catch (e) {
      whcSetStatus(String(e));
    } finally {
      if (btn) btn.disabled = false;
    }
  }

  // Band labels for semantic similarity
  const SEMANTIC_BAND_LABELS = {
    'composite': 'Composite',
    'environment': 'Environment',
    'history': 'History',
    'culture': 'Culture',
    'modern': 'Modern'
  };

  async function whcShowSimilarText(band = 'composite') {
    if (!whcSelected) return;

    const btn = document.getElementById('whc-similar-text-btn');
    if (btn) btn.disabled = true;

    clearSimilarResults();

    const bandLabel = SEMANTIC_BAND_LABELS[band] || band;
    try {
      whcSetStatus(`Finding semantically similar cities (${bandLabel})…`);
      const data = await fetchWhcSimilarText(whcSelected.id, band, 5);
      renderWhcSimilarSites(data, whcSelected, 'text', band);
      whcSetStatus('');
    } catch (e) {
      whcSetStatus(String(e));
    } finally {
      if (btn) btn.disabled = false;
    }
  }

  async function showCitySummaries(cityId, cityName, country) {
    const modal = new bootstrap.Modal(document.getElementById('summariesModal'));
    const titleEl = document.getElementById('summariesModalLabel');
    const bodyEl = document.getElementById('summariesModalBody');

    // Set title and show loading state
    titleEl.textContent = `${cityName}, ${country}`;
    bodyEl.innerHTML = '<div class="text-center text-muted py-4">Loading summaries...</div>';
    modal.show();

    try {
      const resp = await fetch(`/api/whc-summaries?city_id=${encodeURIComponent(cityId)}`);
      if (!resp.ok) {
        throw new Error(`Failed to load summaries (${resp.status})`);
      }
      const data = await resp.json();

      if (!data.summaries || data.summaries.length === 0) {
        bodyEl.innerHTML = '<div class="text-muted">No summaries available for this city.</div>';
        return;
      }

      // Band display names
      const bandLabels = {
        'environment': 'Environment',
        'history': 'History',
        'culture': 'Culture',
        'modern': 'Modern'
      };

      // Build HTML for summaries
      const html = data.summaries.map(s => `
        <div class="mb-4">
          <h5 class="text-secondary border-bottom pb-1">${bandLabels[s.band] || s.band}</h5>
          <p class="mb-0">${escapeHtml(s.summary)}</p>
        </div>
      `).join('');

      bodyEl.innerHTML = html;
    } catch (e) {
      bodyEl.innerHTML = `<div class="text-danger">Error: ${escapeHtml(String(e))}</div>`;
    }
  }

  function ensureMap() {
    if (map) return;
    if (!window.L) {
      console.warn('Leaflet (window.L) not found. Map will remain inert until Leaflet is included.');
      return;
    }

    map = L.map('map').setView([0, 0], 2);

    // Overlay (toggle): standard OSM streets/labels
    // NOTE: kept as an overlay because the hillshade tiles are JPEG (no alpha) and must sit underneath.
    const osmOverlay = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      opacity: 0.50,
      attribution: '&copy; OpenStreetMap contributors'
    });

    // Overlay (ALWAYS ON): hillshade (terrain context).
    // Source: OpenStreetMap US tileservice (TileJSON: https://tiles.openstreetmap.us/raster/hillshade.json)
    const hillshadeLayer = L.tileLayer('https://tiles.openstreetmap.us/raster/hillshade/{z}/{x}/{y}.jpg', {
      maxZoom: 12,
      opacity: 1.0,
      className: 'edop-hillshade',
      attribution: 'Hillshade: &copy; OpenStreetMap US'
    });

    // Add defaults
    // Hillshade is the always-on environmental context (base).
    hillshadeLayer.addTo(map);
    osmOverlay.addTo(map);
    // Streets/labels are ON by default.
    // (User can toggle them on via the layer control.)

    // Layer switcher: hillshade is always on; streets are toggleable.
    L.control.layers(
      null,
      {
        'Streets / labels': osmOverlay
      },
      { collapsed: true }
    ).addTo(map);
  }

  function setMarkerFromLonLat(lon, lat) {
    ensureMap();
    if (!map) return;
    const ll = [lat, lon];
    if (!marker) {
      marker = L.marker(ll).addTo(map);
    } else {
      marker.setLatLng(ll);
    }
    map.setView(ll, 9);
  }

  function clearMarker() {
    if (marker && map) {
      try {
        map.removeLayer(marker);
      } catch (e) {
        // ignore
      }
    }
    marker = null;
  }

  function clearBasinLayer() {
    if (basinLayer && map) {
      map.removeLayer(basinLayer);
    }
    basinLayer = null;
  }

  function tryParseGeojson(value) {
    // Signature may return geojson as an object or as a JSON-encoded string.
    if (!value) return null;
    if (typeof value === 'object') return value;
    if (typeof value === 'string') {
      try {
        return JSON.parse(value);
      } catch (e) {
        return null;
      }
    }
    return null;
  }

  function setBasinFromSignature(sig) {
    ensureMap();
    if (!map) return;

    // Field currently named `geom_geojson` in your signature payload.
    const gj = tryParseGeojson(sig && sig.geom_geojson);
    if (!gj) {
      clearBasinLayer();
      return;
    }

    // Replace prior overlay
    clearBasinLayer();

    // Add GeoJSON overlay (supports Polygon/MultiPolygon)
    basinLayer = L.geoJSON(gj, {
      // keep styling minimal; Leaflet defaults are fine for now
    }).addTo(map);

    // Optional: fit to polygon bounds if they are reasonable
    try {
      const b = basinLayer.getBounds();
      if (b && b.isValid()) {
        map.fitBounds(b.pad(0.05));
      }
    } catch (e) {
      // ignore
    }
  }

  function renderResolvedPlace(obj) {
    const pre = document.getElementById('main-resolved');
    pre.textContent = obj ? JSON.stringify(obj, null, 2) : '';
  }

  function escapeHtml(s) {
    if (s === null || s === undefined) return '';
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function formatValue(v) {
    if (v === null || v === undefined) return '';
    if (typeof v === 'number') {
      // Keep pilot formatting simple: round long floats lightly
      const abs = Math.abs(v);
      if (abs !== 0 && abs < 1) return v.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
      if (!Number.isInteger(v) && abs >= 1 && abs < 1000) return v.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
      return String(v);
    }
    if (typeof v === 'object') {
      // Render small objects (e.g., pnv_shares) compactly
      try {
        return JSON.stringify(v);
      } catch (e) {
        return String(v);
      }
    }
    return String(v);
  }

  function humanizeKey(k) {
    // Minimal pilot prettifier
    return String(k)
      .replaceAll('_', ' ')
      .replace(/\bavg\b/gi, 'avg')
      .replace(/\bmin\b/gi, 'min')
      .replace(/\bmax\b/gi, 'max');
  }

  function renderSignature(sig) {
    const pre = document.getElementById('output');
    const summaryEl = document.getElementById('profile-summary');
    const accEl = document.getElementById('profile-accordions');

    // Clear
    if (summaryEl) summaryEl.innerHTML = '';
    if (accEl) accEl.innerHTML = '';

    if (!sig) {
      if (pre) {
        pre.style.display = 'none';
        pre.textContent = '';
      }
      return;
    }

    const hasGrouped = sig.profile_summary && sig.profile_groups;

    if (!hasGrouped) {
      // Fallback to raw JSON
      if (pre) {
        pre.style.display = '';
        pre.textContent = JSON.stringify(sig, null, 2);
      }
      return;
    }

    // Hide raw JSON in normal path
    if (pre) {
      pre.style.display = 'none';
      pre.textContent = '';
    }

    // ---------- Summary ----------
    if (summaryEl) {
      const items = Array.isArray(sig.profile_summary) ? sig.profile_summary : [];
      if (items.length) {
        const rows = items
          .filter(it => it && it.value !== undefined)
          .map(it => {
            const label = escapeHtml(it.label || humanizeKey(it.key || ''));
            const value = escapeHtml(formatValue(it.value));
            return `<div class="d-flex justify-content-between gap-2 py-1 border-bottom"><div class="text-muted">${label}</div><div class="text-end">${value}</div></div>`;
          })
          .join('');
        summaryEl.innerHTML = `
          <div class="card">
            <div class="card-body p-2">
              <div class="fw-semibold mb-1">Summary</div>
              ${rows}
            </div>
          </div>
        `;
      }
    }

    // ---------- Accordions ----------
    if (accEl) {
      const groups = sig.profile_groups || {};
      const order = ['A', 'B', 'C', 'D'];
      const accId = 'profileAccordion';

      const panels = order
        .filter(code => groups[code])
        .map((code, idx) => {
          const g = groups[code];
          const label = escapeHtml(g.label || code);
          const items = Array.isArray(g.items) ? g.items : [];

          const body = items.map(it => {
            const k = it.key || '';
            const l = escapeHtml(it.label || humanizeKey(k));
            const v = escapeHtml(formatValue(it.value));
            return `<div class="d-flex justify-content-between gap-2 py-1 border-bottom"><div class="text-muted">${l}</div><div class="text-end">${v}</div></div>`;
          }).join('');

          const headingId = `heading-${code}`;
          const collapseId = `collapse-${code}`;

          return `
            <div class="accordion-item">
              <h2 class="accordion-header" id="${headingId}">
                <button class="accordion-button ${idx === 0 ? '' : 'collapsed'}" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="${idx === 0 ? 'true' : 'false'}" aria-controls="${collapseId}">
                  ${escapeHtml(code)} — ${label}
                </button>
              </h2>
              <div id="${collapseId}" class="accordion-collapse collapse ${idx === 0 ? 'show' : ''}" aria-labelledby="${headingId}" data-bs-parent="#${accId}">
                <div class="accordion-body p-2">
                  ${body || '<div class="text-muted">(no fields)</div>'}
                </div>
              </div>
            </div>
          `;
        })
        .join('');

      accEl.innerHTML = `
        <div class="accordion" id="${accId}">
          ${panels}
        </div>
      `;
    }
  }

  async function fetchSignature(lon, lat) {
    const url = `/api/signature?lon=${encodeURIComponent(lon)}&lat=${encodeURIComponent(lat)}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`Signature request failed (${resp.status}): ${txt}`);
    }
    return await resp.json();
  }

  async function resolveByLonLat(lon, lat) {
    // Clear cluster label (only shown for WH sites)
    showClusterLabel(null);

    const resolved = {
      label: 'lon/lat input',
      source: 'lonlat',
      location: { type: 'Point', coordinates: [Number(lon), Number(lat)] }
    };
    renderResolvedPlace(resolved);
    setMarkerFromLonLat(Number(lon), Number(lat));

    const sig = await fetchSignature(lon, lat);
    renderSignature(sig);
    setBasinFromSignature(sig);
  }

  async function resolveByName(name) {
    // Clear cluster label (only shown for WH sites)
    showClusterLabel(null);

    // Call EDOP backend resolver (server-side WHG token usage)
    const url = `/api/resolve?name=${encodeURIComponent(name)}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`Resolve request failed (${resp.status}): ${txt}`);
    }

    const resolved = await resp.json();
    renderResolvedPlace(resolved);

    // If we got coordinates back, proceed to signature
    if (resolved && resolved.location && resolved.location.type === 'Point' && resolved.location.coordinates) {
      const lon = resolved.location.coordinates[0];
      const lat = resolved.location.coordinates[1];
      setMarkerFromLonLat(Number(lon), Number(lat));
      const sig = await fetchSignature(lon, lat);
      renderSignature(sig);
      setBasinFromSignature(sig);
      return;
    }

    // Otherwise show why we couldn't proceed
    renderSignature({
      detail: 'Resolved via WHG, but no coordinates were returned; cannot compute environmental profile.',
      resolved
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    // Wire Timbuktu test button (existing behavior)
    const testBtn = document.getElementById('test-btn');
    testBtn.addEventListener('click', async () => {
      // Timbuktu WH site (approx): lon=-2.999444444, lat=16.77333333
      const lon = -2.999444444;
      const lat = 16.77333333;
      document.getElementById('main-lon').value = lon;
      document.getElementById('main-lat').value = lat;
      document.getElementById('main-name').value = '';
      renderResolvedPlace(null);
      renderSignature(null);
      clearBasinLayer();
      try {
        await resolveByLonLat(lon, lat);
      } catch (e) {
        renderSignature({ error: String(e) });
      }
    });

    // Main form submit
    const form = document.getElementById('main-form');
    form.addEventListener('submit', async (evt) => {
      evt.preventDefault();
      renderResolvedPlace(null);
      renderSignature(null);
      clearBasinLayer();

      const lon = document.getElementById('main-lon').value.trim();
      const lat = document.getElementById('main-lat').value.trim();
      const name = document.getElementById('main-name').value.trim();

      try {
        if (lon !== '' && lat !== '') {
          await resolveByLonLat(lon, lat);
          return;
        }
        if (name !== '') {
          await resolveByName(name);
          return;
        }
        renderSignature({ detail: 'Enter lon/lat or a place name.' });
      } catch (e) {
        renderSignature({ error: String(e) });
      }
    });

    // Initialize map if Leaflet is present
    ensureMap();

    // World Heritage: load seed list now (simple pilot behavior)
    whLoadSites();

    // World Heritage: selection handler
    const whSel = document.getElementById('wh-select');
    if (whSel) {
      whSel.addEventListener('change', async () => {
        const v = whSel.value;
        if (!v) return;
        await whSelectById(v);
      });
    }

    // World Heritage: toggle description
    const whBtn = document.getElementById('wh-show-desc');
    if (whBtn) {
      whBtn.addEventListener('click', () => {
        const descBox = document.getElementById('wh-desc');
        if (!whSelected || !whSelected.short_description_en || !descBox) return;

        // Toggle visibility (use 'block' not '' to avoid falsy empty string issue)
        if (descBox.style.display === 'none') {
          descBox.textContent = whSelected.short_description_en;
          descBox.style.display = 'block';
          whBtn.textContent = 'Hide description';
        } else {
          descBox.style.display = 'none';
          descBox.textContent = '';
          whBtn.textContent = 'Show description';
        }
      });
    }

    // World Heritage: similar buttons
    const btnSimilarEnv = document.getElementById('wh-similar-env');
    if (btnSimilarEnv) {
      btnSimilarEnv.addEventListener('click', whShowSimilarEnv);
    }
    const btnSimilarText = document.getElementById('wh-similar-text');
    if (btnSimilarText) {
      btnSimilarText.addEventListener('click', whShowSimilarText);
    }

    // WHC Cities: load cities now
    whcLoadCities();

    // WHC Cities: selection handler
    const whcSel = document.getElementById('whc-select');
    if (whcSel) {
      whcSel.addEventListener('change', async () => {
        const v = whcSel.value;
        if (!v) return;
        await whcSelectById(v);
      });
    }

    // WHC Cities: environmental similarity dropdown
    document.querySelectorAll('#whc-similar-env-btn + .dropdown-menu .dropdown-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.preventDefault();
        if (item.classList.contains('disabled')) return;
        const band = item.getAttribute('data-band');
        whcShowSimilarEnv(band);
      });
    });

    // WHC Cities: semantic similarity dropdown
    document.querySelectorAll('#whc-similar-text-btn + .dropdown-menu .dropdown-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.preventDefault();
        if (item.classList.contains('disabled')) return;
        const band = item.getAttribute('data-band');
        whcShowSimilarText(band);
      });
    });

    // Leaflet often needs an explicit size recalculation when switching tabs.
    // Pilot behavior: treat each tab as its own workflow; clear shared UI + map state on ANY tab change.
    document.querySelectorAll('button[data-bs-toggle="tab"]').forEach((btn) => {
      btn.addEventListener('shown.bs.tab', (evt) => {
        if (map) map.invalidateSize();

        // Always clear shared panels
        renderResolvedPlace(null);
        renderSignature(null);
        showClusterLabel(null);
        clearSimilarResults();

        // Always clear map overlays and reset view
        clearBasinLayer();
        clearMarker();
        if (map) {
          map.setView([0, 0], 2);
        }

        // Tab-specific UI visibility
        const targetSel = (evt && evt.target && evt.target.getAttribute)
          ? evt.target.getAttribute('data-bs-target')
          : null;

        // Show "Resolved place" section only on Main tab
        const resolvedSection = document.getElementById('resolved-place-section');
        if (resolvedSection) {
          resolvedSection.style.display = targetSel === '#panel-main' ? '' : 'none';
        }

        // WH-specific UI reset when entering WH tab
        if (targetSel === '#panel-wh') {
          whSetStatus('');
          const descBox = document.getElementById('wh-desc');
          if (descBox) {
            descBox.style.display = 'none';
            descBox.textContent = '';
          }
        }

        // WHC-specific UI reset when entering WHC tab
        if (targetSel === '#panel-whc') {
          whcSetStatus('');
        }
      });
    });
  });
</script>
{% endblock %}