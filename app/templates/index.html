{% extends "base.html" %}

{% block content %}
<div class="container-fluid">
  <div class="row g-3">

    <!-- LEFT: tabs + forms + outputs -->
    <div class="col-12 col-lg-4">
      <ul class="nav nav-tabs" id="edopTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="tab-main" data-bs-toggle="tab" data-bs-target="#panel-main" type="button" role="tab" aria-controls="panel-main" aria-selected="true">Main</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="tab-compare" data-bs-toggle="tab" data-bs-target="#panel-compare" type="button" role="tab" aria-controls="panel-compare" aria-selected="false">Compare</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="tab-wh" data-bs-toggle="tab" data-bs-target="#panel-wh" type="button" role="tab" aria-controls="panel-wh" aria-selected="false">World Heritage</button>
        </li>
      </ul>

      <div class="tab-content pt-3" id="edopTabContent">

        <!-- MAIN TAB -->
        <div class="tab-pane fade show active" id="panel-main" role="tabpanel" aria-labelledby="tab-main">
          <h4 class="mb-3">Resolve place</h4>

          <form id="main-form" class="mb-3">
            <div class="mb-2">
              <label class="form-label" for="main-lon">Longitude</label>
              <input class="form-control" id="main-lon" name="lon" type="number" step="any" placeholder="e.g. -2.99944" />
            </div>
            <div class="mb-2">
              <label class="form-label" for="main-lat">Latitude</label>
              <input class="form-control" id="main-lat" name="lat" type="number" step="any" placeholder="e.g. 16.77333" />
            </div>

            <div class="my-3 text-muted">— or —</div>

            <div class="mb-2">
              <label class="form-label" for="main-name">Place name (WHG suggest; first hit only)</label>
              <input class="form-control" id="main-name" name="name" type="text" placeholder="e.g. Timbuktu" />
              <div class="form-text">Name resolution uses WHG via the EDOP backend (top-ranked hit only); the WHG token is never sent to the browser.</div>
            </div>

            <div class="d-flex gap-2 mt-3">
              <button class="btn btn-primary" id="main-resolve-btn" type="submit">Resolve</button>
              <button class="btn btn-outline-secondary" id="test-btn" type="button">Use Timbuktu lon/lat</button>
            </div>
          </form>
        </div>

        <!-- COMPARE TAB (placeholder) -->
        <div class="tab-pane fade" id="panel-compare" role="tabpanel" aria-labelledby="tab-compare">
          <p class="text-muted">Compare UI coming next (two places → two profiles).</p>
        </div>

        <!-- WORLD HERITAGE TAB -->
        <div class="tab-pane fade" id="panel-wh" role="tabpanel" aria-labelledby="tab-wh">
          <h4 class="mb-3">World Heritage sites</h4>

          <div class="mb-2">
            <label class="form-label" for="wh-select">Choose a site</label>
            <select class="form-select" id="wh-select" disabled>
              <option value="">Loading…</option>
            </select>
            <div class="form-text">Seed list will come from the EDOP backend; selecting a site will drop a marker and compute an environmental profile.</div>
          </div>

          <div class="mt-3">
            <button class="btn btn-outline-secondary" id="wh-show-desc" type="button" disabled>Show description</button>
          </div>

          <div class="mt-3">
            <div class="alert alert-light" id="wh-desc" style="display:none;"></div>
          </div>
        </div>

      </div>

      <!-- Outputs (shared across tabs) -->
      <div class="mt-3">
        <h5 class="mb-2">Environmental profile</h5>

        <!-- Summary + grouped accordions (preferred) -->
        <div id="profile-summary" class="small"></div>
        <div id="profile-accordions" class="mt-2"></div>

        <!-- Fallback (raw JSON) -->
        <pre id="output" class="bg-light p-2" style="min-height: 12rem; display:none;"></pre>
      </div>

      <div class="mb-3 mt-3">
        <h5 class="mb-2">Resolved place</h5>
        <pre id="main-resolved" class="bg-light p-2" style="min-height: 7rem;"></pre>
      </div>
    </div>

    <!-- RIGHT: map (always visible) -->
    <div class="col-12 col-lg-7">
      <h4 class="mb-3">Map</h4>
      <div id="map" style="height: 420px; border: 1px solid #ddd;"></div>
      <div class="form-text mt-2">Map plumbing is wired for a marker now; polygon overlay can be added once <code>/api/signature</code> returns GeoJSON geometry.</div>
    </div>

  </div>
</div>

<script>
  // ResolvedPlace shape (client-side):
  // {
  //   label: string,
  //   source: 'lonlat' | 'whg_suggest',
  //   location?: { type: 'Point', coordinates: [lon, lat] },
  //   meta?: object
  // }

  let map = null;
  let marker = null;
  let basinLayer = null; // GeoJSON polygon overlay from signature (sub-basin)
  // World Heritage seed list state
  let whSites = [];
  let whSelected = null;
  function setMarkerWithPopup(lon, lat, popupHtml) {
    setMarkerFromLonLat(lon, lat);
    if (!marker) return;
    marker.unbindPopup();
    if (popupHtml) {
      marker.bindPopup(popupHtml);
    }
  }

  function whSetStatus(msg) {
    // Lightweight status: show in description alert area if present, else console.
    const el = document.getElementById('wh-desc');
    if (!el) {
      console.log(msg);
      return;
    }
    if (!msg) {
      el.style.display = 'none';
      el.textContent = '';
      return;
    }
    el.style.display = '';
    el.textContent = msg;
  }

  async function whLoadSites() {
    const sel = document.getElementById('wh-select');
    const btnDesc = document.getElementById('wh-show-desc');
    const descBox = document.getElementById('wh-desc');

    if (!sel) return;

    sel.disabled = true;
    if (btnDesc) btnDesc.disabled = true;
    if (descBox) {
      descBox.style.display = 'none';
      descBox.textContent = '';
    }

    sel.innerHTML = '<option value="">Loading…</option>';

    try {
      const resp = await fetch('/api/wh-sites');
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`WH sites request failed (${resp.status}): ${txt}`);
      }
      const data = await resp.json();
      whSites = (data && data.sites) ? data.sites : [];

      // Populate dropdown
      sel.innerHTML = '<option value="">Select a site…</option>';
      whSites.forEach((s) => {
        const opt = document.createElement('option');
        opt.value = String(s.id_no);
        opt.textContent = s.name_en;
        sel.appendChild(opt);
      });

      sel.disabled = false;
    } catch (e) {
      sel.innerHTML = '<option value="">(Seed list unavailable)</option>';
      sel.disabled = true;
      whSetStatus(String(e));
    }
  }

  async function whSelectById(idNo) {
    const btnDesc = document.getElementById('wh-show-desc');
    const descBox = document.getElementById('wh-desc');

    whSelected = whSites.find((s) => String(s.id_no) === String(idNo)) || null;

    if (descBox) {
      descBox.style.display = 'none';
      descBox.textContent = '';
    }

    if (!whSelected) {
      if (btnDesc) btnDesc.disabled = true;
      return;
    }

    // This path is not WHG resolution; clear Resolved place
    renderResolvedPlace(null);

    const loc = whSelected.location;
    if (!loc || loc.type !== 'Point' || !loc.coordinates || loc.coordinates.length < 2) {
      whSetStatus('Selected site has no usable Point geometry.');
      if (btnDesc) btnDesc.disabled = true;
      return;
    }

    const lon = Number(loc.coordinates[0]);
    const lat = Number(loc.coordinates[1]);

    const popupHtml = `
      <div style="max-width: 260px;">
        <strong>${whSelected.name_en}</strong><br/>
        <span class="text-muted">${whSelected.states_name_en || ''}</span>
      </div>
    `;
    setMarkerWithPopup(lon, lat, popupHtml);

    // Enable description button if text exists
    if (btnDesc) btnDesc.disabled = !(whSelected.short_description_en && whSelected.short_description_en.length);

    try {
      whSetStatus('Computing environmental profile…');
      const sig = await fetchSignature(lon, lat);
      renderSignature(sig);
      setBasinFromSignature(sig);
      whSetStatus('');
      if (marker && marker.getPopup()) marker.openPopup();
    } catch (e) {
      whSetStatus(String(e));
      renderSignature({ error: String(e) });
    }
  }

  function ensureMap() {
    if (map) return;
    if (!window.L) {
      console.warn('Leaflet (window.L) not found. Map will remain inert until Leaflet is included.');
      return;
    }
    map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
  }

  function setMarkerFromLonLat(lon, lat) {
    ensureMap();
    if (!map) return;
    const ll = [lat, lon];
    if (!marker) {
      marker = L.marker(ll).addTo(map);
    } else {
      marker.setLatLng(ll);
    }
    map.setView(ll, 9);
  }

  function clearMarker() {
    if (marker && map) {
      try {
        map.removeLayer(marker);
      } catch (e) {
        // ignore
      }
    }
    marker = null;
  }

  function clearBasinLayer() {
    if (basinLayer && map) {
      map.removeLayer(basinLayer);
    }
    basinLayer = null;
  }

  function tryParseGeojson(value) {
    // Signature may return geojson as an object or as a JSON-encoded string.
    if (!value) return null;
    if (typeof value === 'object') return value;
    if (typeof value === 'string') {
      try {
        return JSON.parse(value);
      } catch (e) {
        return null;
      }
    }
    return null;
  }

  function setBasinFromSignature(sig) {
    ensureMap();
    if (!map) return;

    // Field currently named `geom_geojson` in your signature payload.
    const gj = tryParseGeojson(sig && sig.geom_geojson);
    if (!gj) {
      clearBasinLayer();
      return;
    }

    // Replace prior overlay
    clearBasinLayer();

    // Add GeoJSON overlay (supports Polygon/MultiPolygon)
    basinLayer = L.geoJSON(gj, {
      // keep styling minimal; Leaflet defaults are fine for now
    }).addTo(map);

    // Optional: fit to polygon bounds if they are reasonable
    try {
      const b = basinLayer.getBounds();
      if (b && b.isValid()) {
        map.fitBounds(b.pad(0.05));
      }
    } catch (e) {
      // ignore
    }
  }

  function renderResolvedPlace(obj) {
    const pre = document.getElementById('main-resolved');
    pre.textContent = obj ? JSON.stringify(obj, null, 2) : '';
  }

  function escapeHtml(s) {
    if (s === null || s === undefined) return '';
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function formatValue(v) {
    if (v === null || v === undefined) return '';
    if (typeof v === 'number') {
      // Keep pilot formatting simple: round long floats lightly
      const abs = Math.abs(v);
      if (abs !== 0 && abs < 1) return v.toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
      if (!Number.isInteger(v) && abs >= 1 && abs < 1000) return v.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
      return String(v);
    }
    if (typeof v === 'object') {
      // Render small objects (e.g., pnv_shares) compactly
      try {
        return JSON.stringify(v);
      } catch (e) {
        return String(v);
      }
    }
    return String(v);
  }

  function humanizeKey(k) {
    // Minimal pilot prettifier
    return String(k)
      .replaceAll('_', ' ')
      .replace(/\bavg\b/gi, 'avg')
      .replace(/\bmin\b/gi, 'min')
      .replace(/\bmax\b/gi, 'max');
  }

  function renderSignature(sig) {
    const pre = document.getElementById('output');
    const summaryEl = document.getElementById('profile-summary');
    const accEl = document.getElementById('profile-accordions');

    // Clear
    if (summaryEl) summaryEl.innerHTML = '';
    if (accEl) accEl.innerHTML = '';

    if (!sig) {
      if (pre) {
        pre.style.display = 'none';
        pre.textContent = '';
      }
      return;
    }

    const hasGrouped = sig.profile_summary && sig.profile_groups;

    if (!hasGrouped) {
      // Fallback to raw JSON
      if (pre) {
        pre.style.display = '';
        pre.textContent = JSON.stringify(sig, null, 2);
      }
      return;
    }

    // Hide raw JSON in normal path
    if (pre) {
      pre.style.display = 'none';
      pre.textContent = '';
    }

    // ---------- Summary ----------
    if (summaryEl) {
      const items = Array.isArray(sig.profile_summary) ? sig.profile_summary : [];
      if (items.length) {
        const rows = items
          .filter(it => it && it.value !== undefined)
          .map(it => {
            const label = escapeHtml(it.label || humanizeKey(it.key || ''));
            const value = escapeHtml(formatValue(it.value));
            return `<div class="d-flex justify-content-between gap-2 py-1 border-bottom"><div class="text-muted">${label}</div><div class="text-end">${value}</div></div>`;
          })
          .join('');
        summaryEl.innerHTML = `
          <div class="card">
            <div class="card-body p-2">
              <div class="fw-semibold mb-1">Summary</div>
              ${rows}
            </div>
          </div>
        `;
      }
    }

    // ---------- Accordions ----------
    if (accEl) {
      const groups = sig.profile_groups || {};
      const order = ['A', 'B', 'C', 'D'];
      const accId = 'profileAccordion';

      const panels = order
        .filter(code => groups[code])
        .map((code, idx) => {
          const g = groups[code];
          const label = escapeHtml(g.label || code);
          const items = Array.isArray(g.items) ? g.items : [];

          const body = items.map(it => {
            const k = it.key || '';
            const l = escapeHtml(it.label || humanizeKey(k));
            const v = escapeHtml(formatValue(it.value));
            return `<div class="d-flex justify-content-between gap-2 py-1 border-bottom"><div class="text-muted">${l}</div><div class="text-end">${v}</div></div>`;
          }).join('');

          const headingId = `heading-${code}`;
          const collapseId = `collapse-${code}`;

          return `
            <div class="accordion-item">
              <h2 class="accordion-header" id="${headingId}">
                <button class="accordion-button ${idx === 0 ? '' : 'collapsed'}" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="${idx === 0 ? 'true' : 'false'}" aria-controls="${collapseId}">
                  ${escapeHtml(code)} — ${label}
                </button>
              </h2>
              <div id="${collapseId}" class="accordion-collapse collapse ${idx === 0 ? 'show' : ''}" aria-labelledby="${headingId}" data-bs-parent="#${accId}">
                <div class="accordion-body p-2">
                  ${body || '<div class="text-muted">(no fields)</div>'}
                </div>
              </div>
            </div>
          `;
        })
        .join('');

      accEl.innerHTML = `
        <div class="accordion" id="${accId}">
          ${panels}
        </div>
      `;
    }
  }

  async function fetchSignature(lon, lat) {
    const url = `/api/signature?lon=${encodeURIComponent(lon)}&lat=${encodeURIComponent(lat)}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`Signature request failed (${resp.status}): ${txt}`);
    }
    return await resp.json();
  }

  async function resolveByLonLat(lon, lat) {
    const resolved = {
      label: 'lon/lat input',
      source: 'lonlat',
      location: { type: 'Point', coordinates: [Number(lon), Number(lat)] }
    };
    renderResolvedPlace(resolved);
    setMarkerFromLonLat(Number(lon), Number(lat));

    const sig = await fetchSignature(lon, lat);
    renderSignature(sig);
    setBasinFromSignature(sig);
  }

  async function resolveByName(name) {
    // Call EDOP backend resolver (server-side WHG token usage)
    const url = `/api/resolve?name=${encodeURIComponent(name)}`;
    const resp = await fetch(url);
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`Resolve request failed (${resp.status}): ${txt}`);
    }

    const resolved = await resp.json();
    renderResolvedPlace(resolved);

    // If we got coordinates back, proceed to signature
    if (resolved && resolved.location && resolved.location.type === 'Point' && resolved.location.coordinates) {
      const lon = resolved.location.coordinates[0];
      const lat = resolved.location.coordinates[1];
      setMarkerFromLonLat(Number(lon), Number(lat));
      const sig = await fetchSignature(lon, lat);
      renderSignature(sig);
      setBasinFromSignature(sig);
      return;
    }

    // Otherwise show why we couldn't proceed
    renderSignature({
      detail: 'Resolved via WHG, but no coordinates were returned; cannot compute environmental profile.',
      resolved
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    // Wire Timbuktu test button (existing behavior)
    const testBtn = document.getElementById('test-btn');
    testBtn.addEventListener('click', async () => {
      // Timbuktu WH site (approx): lon=-2.999444444, lat=16.77333333
      const lon = -2.999444444;
      const lat = 16.77333333;
      document.getElementById('main-lon').value = lon;
      document.getElementById('main-lat').value = lat;
      document.getElementById('main-name').value = '';
      renderResolvedPlace(null);
      renderSignature(null);
      clearBasinLayer();
      try {
        await resolveByLonLat(lon, lat);
      } catch (e) {
        renderSignature({ error: String(e) });
      }
    });

    // Main form submit
    const form = document.getElementById('main-form');
    form.addEventListener('submit', async (evt) => {
      evt.preventDefault();
      renderResolvedPlace(null);
      renderSignature(null);
      clearBasinLayer();

      const lon = document.getElementById('main-lon').value.trim();
      const lat = document.getElementById('main-lat').value.trim();
      const name = document.getElementById('main-name').value.trim();

      try {
        if (lon !== '' && lat !== '') {
          await resolveByLonLat(lon, lat);
          return;
        }
        if (name !== '') {
          await resolveByName(name);
          return;
        }
        renderSignature({ detail: 'Enter lon/lat or a place name.' });
      } catch (e) {
        renderSignature({ error: String(e) });
      }
    });

    // Initialize map if Leaflet is present
    ensureMap();

    // World Heritage: load seed list now (simple pilot behavior)
    whLoadSites();

    // World Heritage: selection handler
    const whSel = document.getElementById('wh-select');
    if (whSel) {
      whSel.addEventListener('change', async () => {
        const v = whSel.value;
        if (!v) return;
        await whSelectById(v);
      });
    }

    // World Heritage: show description
    const whBtn = document.getElementById('wh-show-desc');
    if (whBtn) {
      whBtn.addEventListener('click', () => {
        const descBox = document.getElementById('wh-desc');
        if (!whSelected || !whSelected.short_description_en || !descBox) return;
        descBox.textContent = whSelected.short_description_en;
        descBox.style.display = '';
      });
    }

    // Leaflet often needs an explicit size recalculation when switching tabs.
    // Pilot behavior: treat each tab as its own workflow; clear shared UI + map state on ANY tab change.
    document.querySelectorAll('button[data-bs-toggle="tab"]').forEach((btn) => {
      btn.addEventListener('shown.bs.tab', (evt) => {
        if (map) map.invalidateSize();

        // Always clear shared panels
        renderResolvedPlace(null);
        renderSignature(null);

        // Always clear map overlays and reset view
        clearBasinLayer();
        clearMarker();
        if (map) {
          map.setView([0, 0], 2);
        }

        // WH-specific UI reset only when entering WH tab
        const targetSel = (evt && evt.target && evt.target.getAttribute)
          ? evt.target.getAttribute('data-bs-target')
          : null;

        if (targetSel === '#panel-wh') {
          whSetStatus('');
          const descBox = document.getElementById('wh-desc');
          if (descBox) {
            descBox.style.display = 'none';
            descBox.textContent = '';
          }
        }
      });
    });
  });
</script>
{% endblock %}